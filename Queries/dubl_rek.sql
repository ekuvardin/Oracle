set serveroutput on size 100000
SET VERIFY OFF
SET FEEDBACK OFF
SET TERMOUT OFF
set linesize 180

/*
  Если на схеме версия ТЯ >= 7.4.0.2, то в АРМе "Администратор словаря данных" при добавлении нового реквизита, который 
  приводит к тому, что несколько реквизитов ссылаются на одну колонку, выдастся ошибка, и следует указать другое короткое имя для реквизита.
  
  Если же такие реквизиты уже существовали, то необходимо решить проблему в обязательном порядке, если используется JAVA-компилятор.
  Если JAVA-компилятор не используется, то текущие ошибки могут привести к ошибкам в бизнес-логике. 
  
  Решение проблемы разберем на примере:
  
  Пусть у нас такой вывод
  ----------------------------------------------------------------------------------- 
  ТБП : PLATFORM_TEST
  Колонка : C_ZZZ 
  Реквизиты : ZZ,ZZZ
  ----------------------------------------------------------------------------------- 
  1. В class_tab_columns для соответствующего класса найти реквизиты(выданные dubl_error.log), которые ссылаются на одну колонку.
    
    На нашем тестовом примере  мы видим 2 проблемных реквизитов, значит, поменять имя колонки нужно только для одного из них.
    
    Сделаем запрос 
        select * from class_tab_columns c where c.qual in('ZZ','ZZZ') and c.class_id = 'PLATFORM_TEST';
        
        1.1 Очевидно, что если у реквизитов одинаковые типы(см. class_tab_columns.host_type), то проблем при конвертации данных из одного реквизита
        в другой не будет, и главное - можно изменять имя колонки любого из реквизитов на Ваше усмотрение.
        
        Если типы у реквизитов одинаковые - выберите один из них, который не будете вообще трогать и переходите на к пункту 1.2
        
        Если же типы разные:        
        Нужно определить реквизит, который точно не будем менять.Выполним запрос:

        select u.TABLE_NAME, u.COLUMN_NAME, c.qual
        from user_tab_columns u, class_tab_columns c
        where u.table_name = (select table_name from class_tables where class_id = 'PLATFORM_TEST')
              and c.qual in('Z','ZZ') and c.class_id = 'PLATFORM_TEST' and c.column_name = u.COLUMN_NAME
              and c.host_type = data_type||
                      case
                      when data_precision is not null and nvl(data_scale,0)>0 then '('||data_precision||','||data_scale||')'
                      when data_precision is not null and nvl(data_scale,0)=0 then '('||data_precision||')'
                      when data_precision is null and data_scale is not null then '(*,'||data_scale||')'
                      when char_length>0 then '('||char_length||')'  end;
        
        Те записи, которые выдаст запрос, означают, что именно выбранный реквизит(ы)(из всех, которые дублируются) отображается на колонку и колонка имеет правильный тип.
        Если записей несколько - выбирайте любой реквизит из них. Именно его мы и не будем менять и переходите к пункту 1.2
    
        1.2 Для каждого из оставшихся реквизитов:
          1.2.1 Если какого-либо из реквизитов, выведенного скриптом в dubl_error.log, не окажется в class_tab_columns,
          то у этого реквизита в АРМе "Администратор словаря данных" необходимо и достаточно переименовать короткое имя так, чтобы
          оно было или больше 28 символов, или "C_[КОРОТКОЕ ИМЯ]" было уникальным  в колонке column_name таблицы class_tab_columns для заданного класса.
          
          1.2.2. Если реквизит с заданным коротким именем есть в class_tab_columns, то колонку column_name таблицы class_tab_columns для заданного реквизита
          необходимо изменить на имя, начинающееся с "C_[ЛЮБОЕ ИМЯ, ДОПУСТИМОЕ Oracle]", так, чтобы новое имя колонки было уникальным
          в class_tab_columns для заданного класса, в самой таблице Oracle такой колонки не существовало и новое имя должно иметь длину <=30 символов.
    
    2. Нажать "Хранение" в АРМе "Администратор словаря данных" в окне редактирования ТБП на вкладке "Реквизиты".
    Если ошибки о дублировании реквизитов не выдалось, то проблема решена.
    
    3. В новую колонку по необходимости скопировать данные, которые были в старой колонке и преобразовать к требуемому формату.
*/

spool dubl_error.log

begin
  dbms_output.put_line('Список ТБП, в которых несколько рекзвизитов ссылаются на одну колонку таблицы ТБП.');
  dbms_output.put_line('-----------------------------------------------------------------------------------');
  -- Здесь мы получаем имя класса, имя колонки, список дублируемых реквизитов
  for c in(select  a.class_id, a.col_name, listagg(a.qual,',') within group(order by a.qual) as attrs
           from(-- Реквизит может быть в class_attributes, но его может не быть в class_tab_columns по причинам:
                  -- произошла внутренняя ошибка
                  -- мы уже пытались добавить реквизит, и ядро сообщило нам, что колонка дублируется
             
             -- Так как мы отсеили length(hq.qual) > 28(см. условие where), поэтому второй параметр class_mgr.make_column_name уже не важен и должен быть >=0
             -- Если второй параметр <0, то колонка формируется со служебным префиксом "С$" (опять же если length(hq.qual)<28, то имеет значение лишь знак параметра, а не его значение)
             -- колонки такого типа нас не интересуют.
             select hq.qual, nvl(ct.column_name, class_mgr.make_column_name(hq.qual,0)) as col_name, hq.class_id
             from
              class_tab_columns ct,
                 (-- Если в class_attributes в колонке [SELF_CLASS_ID] содержится имя класса(справочник или структура, то есть те классы, которые описаны в class_attributes)
                  -- то мы должны включить еще все реквизиты из класса, указанного в колонке [SELF_CLASS_ID]
                  -- c именами [КОРОТКОЕ ИМЯ РЕКВИЗИТА В ТЕКУЩЕМ КЛАССЕ].[КОРОТКОЕ ИМЯ РЕКВИЗИТА ИЗ КЛАССА [SELF_CLASS_ID]],
                  -- иначе формируется имя = [КОРОТКОЕ ИМЯ РЕКВИЗИТА В ТЕКУЩЕМ КЛАССЕ]. Это делается для связи с class_tab_columns
                  
                  -- Здесь мы получаем исходное имя класса, полное имя реквизита.
                  select connect_by_root ca.class_id as class_id, ltrim(SYS_CONNECT_BY_PATH(ca.attr_id, '.'),'.') as qual
                  from class_attributes ca
                  -- отбираем только листовые узлы дерева. 
                  -- То есть только те реквизиты, у которых [SELF_CLASS_ID] <> "STRUCTURE"
                  where CONNECT_BY_ISLEAF = 1
                  connect by prior ca.self_class_id = ca.class_id)hq
                -- связь построена таким образом, так как реквизит может быть в class_attributes, но его может не быть в class_tab_columns.
                -- Отсеиваем реквизиты, короткое имя которых больше 28 символов. Если длина превышает 28 сиволов,
                -- то ядро само добавит уникальный идентификатор(в пределах ТБП) и колонка никогда не пересечется с какой-либо другой.
             where length(hq.qual) <= 28 and ct.class_id(+) = hq.class_id and ct.qual(+) = hq.qual)a
             group by a.col_name, a.class_id
             having count(*) > 1)
  loop
    dbms_output.put_line('ТБП       : ' || c.class_id);
    dbms_output.put_line('Колонка   : ' || c.col_name);    
    dbms_output.put_line('Реквизиты : ' || c.attrs);
    dbms_output.put_line('-----------------------------------------------------------------------------------');
  end loop;
end;
/

spool off
